tcp连接状态中的close_wait 状态，出现这个状态的原因是被动关闭时，没有发送 fin给主动关闭方。
断开连接的时候，
当发起主动关闭的左边这方发送一个FIN过去后，右边被动关闭的这方要回应一个ACK，这个ACK是TCP回应的，而不是应用程序发送的，此时，被动关闭的一方就处于CLOSE_WAIT状态了。如果此时被动关闭的这一方不再继续调用closesocket,那么他就不会发送接下来的FIN，导致自己老是处于CLOSE_WAIT。只有被动关闭的这一方调用了closesocket,才会发送一个FIN给主动关闭的这一方，同时也使得自己的状态变迁为LAST_ACK
桥接模式：直连网络地址(brige),分配ip地址，内网主机通讯
NAT模式(网络地址转换)：用于共享主机的IP地址，没有ip地址
仅主机模式：与主机共享的专用网络


反向代理三种模式， ip地址、域名、端口、


.h 是函数声明 ， .c是函数定义


epoll监听文件描述符的读写


worker是异步的，也就是说出现i/o时，会直接通过epoll挂起，继续接收请求，那么在worker里面，发起个异步任务，对worker来说，他会做什么处理？或者说是这个异步任务不会造成任何阻塞问题，继续向下执行，而异步任务是通过回调函数来处理结果。（这就解决了在php-fpm的模式下需要跑脚本的情况，例如，发邮件、大文件读写、会造成i/o耗时较长的操作。）如果不用异步任务，这个请求就无法及时返回，最终甚至超时。但对worker的处理请求影响不大，毕竟他也是异步的。综上所诉，使用swoole和nginx作对比，事件模式两者都是用的reactor模式，并发模式，两者都是半同步半异步模式，就是异步接收请求，同步处理事件




swoole框架，由于是常驻内存的，所以一次实例化，他的每一次添加、或者删除、修改变量，都会对全局产生影响？（单例模式）


swoole 和 php-fpm

进程模型是相同的，manager就是负责管理子进程的创建和回收。但php-fpm的worker进程是同步阻塞的，swoole的worker进程是异步非阻塞的。

http-server和fpm的差异是http-server是内存常驻的，PHP程序变成长生命周期的了。变量和对象在使用请求结束后并不会销毁，可以复用。