
文件描述符： 应该是进程每打开一个流 （文件、socket、管道），内核就会返回一个非负的整数，正常来讲，每个进程最多能打开65536个流，在linux里使用 "ulimit -n" 查看，好像默认是 1024；程序可以根据文件描述符，来对 “流” 进行读和写。

网络编程恒古不变的话题，而其中 同步异步、阻塞和非阻塞 就是更脱离不开的一块
刚开始的时候，很容易被这其中的组合所混淆，什么同步阻塞，同步非阻塞，异步非阻塞，（注意没有异步阻塞哦，异步一定是非阻塞的），反正我看过很多说明解释，一直都是各执一词，好像都很有道理的样子。但是最近我看到一篇写得很好的有关这些内容的文章，（贴地址：https://www.cnblogs.com/aspirant/p/6877350.html?utm_source=itdadao&utm_medium=referral） 有兴趣的可以直接去看，而忽略我这个不专业的解释说明。

首先说同步和异步，指的应该是 程序和内核之间沟通交流的两种方式，同步就是，比如说程序要去内核取数据，而内核又不是为一个程序服务，所以说程序就要排队，等待内核返回数据，不知道这样说明是否严谨呢。而异步程序也是要取数据，但和同步 不一样的是，他是VIP用户，他把数据要存的地址告诉内核，让内核准备好数据后，直接把数据放在指定的地址，然后通知程序就行了。如此，鲜明的对比，VIP就不用做无用的等待了。以上两个操作中，都涉及了 内核空间 和 用户空间的交互，顺带一提，此篇就不做深入探讨（因为我也不是很了解）

然后说阻塞和非阻塞，上文链接中有个很好的说法：阻塞就是在io操作时，一直等待数据，而非阻塞就是，轮询取查看IO操作是否完成。突然想到一个更通俗易懂的说法，区分阻塞和非阻塞，那就是判断在io操作时，是否还能做其他东东。。。

怎么样是不是有点混了，这些东西看起来好像是一个动作的两个方面，对，再理一理， 同步和异步就是程序和内核之间的交互，而阻塞和非阻塞就是程序和内核交互时，程序的一种状态。这样说明白了吗？所以说，他们经常会组合在一起谈论。

by the way，真正的异步需要cpu深度参与，拉一个子线程去轮询、去死循环，或者使用select、poll、epool，都不是异步（伪异步）

下面我们分析下各种组合是怎么回事

现在说的io复用模型，就是通过 引进了一个代理(一开始是select,后来是poll)，这个代理很牛，它可以同时观察许多流的I/O事件，如果没有事件，代理就阻塞，线程就不会挨个挨个去轮询了。 这样就不会卡在一个线程里了。一个线程就可操作多个 “流” 了