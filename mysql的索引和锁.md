
##本文主要对mysql的索引 和 锁 做一些总结和资料记录

参考资料：
	[锁](https://www.zybuluo.com/mikumikulch/note/783493)
    [索引](http://blog.sina.com.cn/s/blog_5a15b7d10102xfit.html)
    [数据库系列文章](https://blog.csdn.net/column/details/21829.html) (推荐)


- - -

**联合索引和单独索引**
	在表中，一个字段最好不要既是联合索引 又是 单独索引，对于创建索引的顺序，则会影响查询的效率，例如，name 和 age 字段，先创建联合索引name_age，再创建单独索引name，那么
```sql
explain select * from user where name='zhang' and age=10;
```
这样，就会应用到联合索引 name_age,

| possible_keys| key | Extra |
|--------|--------|
| name,name_age|  name |Using where

但是，你先创建的单独索引name,再创建的联合索引 name_age;
```sql
explain select * from user where name='zhang' abd age=12;
```

那么，这个查询就会用到 name索引，

| possible_keys| key | Extra |
|--------|--------|
| name_age,name|  name_age |

*得出结论就是*
>当一个字段既是联合索引又是单独索引时，那么其创建索引的先后顺序，会影响查询时的索引生效使用情况。

**联合索引**
	还有些情况是，我们经常会听到别说:
    ~~where条件的运行是从右到左的，将选择性强的条件放到最右边，可以先过滤掉大部分的数据（而选择性不强的条件过滤后的结果集仍然很大），在根据其它条件过滤时，需要比较的数据量就少，提高查询的效率~~
    这种说法是肤浅不全面的，因为mysql有自己的查询结构优化器，并不是直接用你给出的sql语句的。
    我觉得之所以有这种说法，是来源于mysql的==最左前缀原理==,
>结论：MySQL遵循最左前缀原理，当查询条件匹配联合索引的前面几列时，可以使用联合索引；否则，不会使用联合索引。**如果where字句中的列全都包含在索引列中**，那么where字句中的字段顺序和索引顺序无关，**但如果是部分包括的话就要看是否满足最左前缀匹配原则了**。

注意以上的粗体字，查询语句只有联合索引的部分字段，就得看*最左前缀原理*

>*总结*
以上场景包含了精确匹配、模糊匹配、范围匹配、多条件匹配的查询语句，大部分业务用的查询都离不开这四种范畴。只要在使用索引时牢记住：
>1. 左前缀原则
>1. 尽量使用索引覆盖查询
>1. 索引常量的查询比范围索引查询效率更高
>1. 当查询涉及范围查询时，尽量将精确匹配的条件放在前面。
>1. 一张表中的索引只会被使用一次（or 条件语句除外）。mysql 会选择最优结果使用相应的索引。

现在我们再说下前面提到的++最左前缀原则++，顾名思义，就是最左优先，那么优先什么，优先的是索引的字段，我们这里指的是联合索引，例如我们建立联合索引name_age,那么就是优先查询name,我们常常听到查询时where紧跟着选择性强的字段，过滤大部分字段。这个是在使用联合索引时才有意义的说法。

**数据库中查询记录时是否每次只能使用一个索引？**
链接：[具体引用说明](https://segmentfault.com/q/1010000003880137)

>如果经常需要同时对两个字段进行AND查询,那么使用两个单独索引不如建立一个复合索引，因为两个单独索引通常数据库只能使用其中一个，而使用复合索引因为索引本身就对应到两个字段上的，效率会有很大提高。


**mysql索引合并:一条sql可以使用多个索引(索引合拼)**
链接：[具体引用说明](http://www.cnblogs.com/digdeep/archive/2015/11/18/4975977.html)

>MySQL5.0之前，一个表一次只能使用一个索引，无法同时使用多个索引分别进行条件扫描，但是从5.1开始，引入了 index merge 优化技术，对同一个表可以使用多个索引分别进行条件扫描。index merge 技术如果简单的说，其实就是：对多个索引分别进行条件扫描，然后将它们各自的结果进行合并(intersect/union)。


**索引合拼 和 组合索引**

>你有索引index1（a,b,c)，这是是联合索引，也叫复合索引、多列索引；
>你有索引index2（a），index3（b），index4（c），然后你的sql中有and、or或union之类的条件对三个索引分别进行条件扫描，然后将各自的结果进行合并，这叫索引合并，这时你用explain查看执行计划会看到有“index merge”字样。
至于两者有没有关系，这怎么讲呢，一般来说，联合索引（复合索引）的效率要比索引合并要高，在能使用联合索引时尽量使用联合索引，当然这要根据具体情况，sql中寸在“or”这样的连接词时，那就可能必须要使用索引合并了。

对于两者的比较，这篇文章解析得很好 [点击前往](https://blog.csdn.net/Holmofy/article/details/80384637) ;


>每个InnoDB表具有一个特殊的索引称为聚簇索引（也叫聚集索引，聚类索引，簇集索引）。如果表上定义有主键，该主键索引就是聚簇索引。如果未定义主键，MySQL取第一个唯一索引（unique）而且只含非空列（NOT NULL）作为主键，InnoDB使用它作为聚簇索引。如果没有这样的列，InnoDB就自己产生一个这样的ID值，它有六个字节，而且是隐藏的，使其作为聚簇索引。
>表中的聚簇索引（clustered index ）就是一级索引，除此之外，表上的其他非聚簇索引都是二级索引，又叫辅助索引（secondary indexes）。
！

**索引覆盖**
链接：[具体引用说明](https://www.cnblogs.com/chenpingzhao/p/4776981.html)

如果索引包含所有满足查询需要的数据的索引成为覆盖索引(Covering Index)，也就是平时所说的不需要回表操作


## 高性能mysql的辅助工具
	例如可以开启慢查询
```sql
	show variables like '%slow_query%';  // 查询是否开启了慢查询
    
    show variables like 'long_query_time';  //慢查询时间
    set global s
```



## mysql的锁
既然说到锁，那就得先说说mysql的事务隔离级别
- [读未提交]
- [读已提交]
- [可重复读]

>注意 FOR UPDATE 仅适用于InnoDB，且必须在事务区块(BEGIN/COMMIT)中才能生效。


1、范围查询放最后， 范围查询会导致后面的排序列用不上索引，但它本身那个值可用到
2、索引列顺序尽量匹配 order by 字句的排序列顺序
3、索引列顺序尽量匹配 group by 子句顺序

4、注意：where 条件的顺序并不影响 索引的处理，真正影响的是建立组合索引的顺序




时间复杂度按n越大算法越复杂来排的话：常数阶O(1)、对数阶O(logn)、线性阶O(n)、线性对数阶O(nlogn)、平方阶O(n²)、立方阶

O(n³)、……k次方阶O(n的k次方)、指数阶O(2的n次方)。
