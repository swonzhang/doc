
<?php

function task($max) {
    $tid = (yield getTaskId()); // <-- here's the syscall!, 关键字yield后面的getTaskId()返回给函数外部，函数外部通过send数据到函数内部，替换yield关键字
    for ($i = 1; $i <= $max; ++$i) {
        echo "This is task $tid iteration $i.\n";
        yield;
    }
}


$tk = task(1);
$tk->current();
$tk->next();
$tk->send('g');


?>

一般写的程序因为各种原因都会休眠，比如IO操作，而IO操作常常会导致进程休眠。所以一般进程都不会长期占用cpu

而死循环这种进程不会休眠，一有机会就占用cpu运行其时间片，所以就会是这种进程占用了大部分cpu时间



对于单核机器来说，在一个时间点，实际上是在执行一个协程，它是串行执行的，（注：线程有可能是并行执行的，存在对统一资源操作问题）之所以用协程会提高效率，是因为在A协程遇到阻塞时（例如读写数据库），会直接跳到下一个B协程，在B协程执行期间，A协程完成读写了。然后它会进入待执行队列，等待下一个时间片的到来。


程序分为IO密集 和CPU密集 两种

而PHP 就应该属于IO密集类型，即是大多是读写数据库，而目前市面上最流行的是nginx+php-fpm模式，只能从量化来解决并发问题（即是打开更多的fpm进程来处理程序，nginx只是个转发工具），但是php计算能力比不上其他语言这是硬伤，只能在IO上做文章，要更快的话，加缓存，加机器，但更应该是从程序本身上去解决。尽量减少读写数据库的时间，然后要异步，即是阻塞时，不能一直等到读写执行完毕，如此效率太差了。php-fpm模式好像是不支持直接使用语言层面的异步。只能通过迂回政策，（例如：redis任务），而swoole的出现，则是给PHP更多的可能性了。



所以我们可以把协程当做 一个“并发程序” ，举个栗子，我们需要同时请求 三个连接， 都是用协程实现，那么我们只会用消耗请求最长的那个时间。这其中有个弊端，就是三个请求的上下文没有依赖其中一个请求的结果。